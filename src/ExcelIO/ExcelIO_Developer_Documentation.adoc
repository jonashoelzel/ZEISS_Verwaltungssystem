= ExcelIO Developer Documentation

{nbsp} +

== 0.0.0.0 Table of Contents

{nbsp} +

* <<0.0.0.0 Table of Contents>>

{nbsp} +

* <<1.0.0.0 OpenXML/Excel - Technical Background>>
** <<1.1.0.0 Examples of Differences>>
*** <<1.1.1.0 Write/Read Dates>>
**** <<1.1.1.1 Writing Dates>>
**** <<1.1.1.2 Reading Dates>>

** <<1.2.0.0 Glossary>>
*** <<1.2.1.0 OpenXML Classes>>
*** <<1.2.2.0  Used Terms and Definitions>>
**** <<1.2.2.1 Empty Table Design>>
**** <<1.2.2.2 Used Table Design>>

{nbsp} +

* <<2.0.0.0 Code Documentation>>
** <<2.1.0.0 Public APIs>>

*** <<2.1.1.0 RowInsert Class>>
**** <<2.1.1.1 Insert with List>>
**** <<2.1.1.1 Insert with Dictionary>>

*** <<2.1.2.0 RowSelect Class>>
**** <<2.1.2.1 SelectAsRows with List>>
**** <<2.1.2.2 SelectWhereAsRows with List and Where Condition>>
**** <<2.1.2.3 SelectAsColumns with List>>
**** <<2.1.2.4 SelectWhereAsColumns with List and Where Condition>>

*** <<2.1.3.0 RowUpdate Class>>
**** <<2.1.3.1 Update with Where Condition>>

*** <<2.1.4.0 RowDelete Class>>
**** <<2.1.4.1 Delete with Where Condition>>
**** <<2.1.4.2 Delete Advanced with Where Condition>>

*** <<2.1.5.0 Others>>
**** <<2.1.5.1 WorksheetExists>>
**** <<2.1.5.2 CheckPathExists>>
**** <<2.1.5.3 IsIDOfWorksheet>>
**** <<2.1.5.4 CheckHeaderColumnsExist>>

** <<2.2.0.0 Technical Documentation and Private APIs (Selection)>>

*** <<2.2.1.0 SharedString>>
**** <<2.2.1.1 (API) GetSharedStringTablePart>>
**** <<2.2.1.2 (API) InsertSharedStringItem>>
**** <<2.2.1.3 (API) AddSharedString>>

*** <<2.2.2.0 Cells>>
**** <<2.2.2.1 (API) CreateCell>>
**** <<2.2.2.1 (API) UpdateCell>>

{nbsp} +

== 1.0.0.0 OpenXML/Excel - Technical Background

{nbsp} +

It is important to note that Microsoft Excel (xlsx) is not fully compatible with the OpenXML specification. +
But the customer requested to work with a Microsoft Excel file. +
That's why we needed to find some workarounds, so that the OpenXML Spreadsheet acts as an reugular Excel File. +

{nbsp} +

=== 1.1.0.0 Examples of Differences

{nbsp} +

==== 1.1.1.0 Write/Read Dates

{nbsp} +

===== 1.1.1.1 Writing Dates

{nbsp} +

OpenXML:
[source]
--
//Normal way. Does NOT work for xlsx (!)
string strdate = objdate.ToOADate().ToString();
cell.DataType = CellValues.Date;
cell.CellValue = new CellValue(strdate);
--

Normally we would use the cell.DataType to mark the cell as date, but MS Excel does not support this DataType of OpenXML. +
Also note, because OpenXML is Open Source it uses the UNIX DateTime-Format, that's why we use OADate. +

MS Excel:
[source]
--
//"StyleIndex" is "1", because we added a new stylesheet (index 0 would be default) with "NumberFormatId=14"
//is in the 2nd item of 'CellFormats' array.

cell.DataType = new EnumValue<CellValues>(CellValues.Number);
cell.StyleIndex = 1;
cell.CellValue = new CellValue(objdate.ToOADate().ToString(CultureInfo.InvariantCulture));
--

In MS Excel we need to create a Stylesheet that contains a cell formatting that MS Excel does interpret as DateTime-Format. +
Excel uses the NumberFormatID=14 for regular DateTime-Formats. +
Because we created one Stylesheet, this Stylesheet is at StyleIndex=1. +

[source]
--
// Add minimal Stylesheet
var stylesPart = spreadsheetDocument.WorkbookPart.AddNewPart<WorkbookStylesPart>();
stylesPart.Stylesheet = new Stylesheet
{
    Fonts = new Fonts(new Font()),
    Fills = new Fills(new Fill()),
    Borders = new Borders(new Border()),
    CellStyleFormats = new CellStyleFormats(new CellFormat()),
    CellFormats =
        new CellFormats(
            new CellFormat(),
            //This Style is for dates in xlsx (Excel) files
            //To use it call StyleIndex=1
            new CellFormat
            {
                NumberFormatId = 14,
                ApplyNumberFormat = true
            })
};
--

Because we need a Stylesheet with NumberFormatID that MS Excel uses to interpret formats we create a minimal Stylesheet with no style (design). +
Excel uses the NumberFormatID=14 for regular DateTime-Formats. +

{nbsp} +

==== 1.1.1.2 Reading Dates

{nbsp} +

OpenXML:
[source]
--
//Normal way in OpenXML. Does NOT work for xlsx (!)
if (cell.DataType is not null && cell.DataType == CellValues.Date)
{
    if (!String.IsNullOrEmpty(cell?.CellValue?.Text))
    {
        //Make sure that the double is converted into the correct format (with '.' instead of ',')
        if (double.TryParse(cell.CellValue.Text, NumberStyles.Float, CultureInfo.InvariantCulture, out double dateTimeDouble))
        {
            return DateTime.FromOADate(dateTimeDouble);
        }
    }
}
--

In OpenXML, you would only check the cell.DataType and then convert the value from an OADate to the normal DateTime. +
But Excel cannot read the CellValues.Date and the entry wouldn't be shown in the Excel as Date (it'll only show a huge number (because Excel does not format to date)). +

MS Excel:
[source]
--
//Check if StyleIndex is a Date Format
if (Int32.TryParse(cell.StyleIndex?.InnerText, out int styleIndex))
{
    //Standard date format
    if (styleIndex >= 12 && styleIndex <= 22
        //Formatted date format
        || styleIndex >= 165 && styleIndex <= 180
        //Number formats that can be interpreted as a number
        || styleIndex >= 1 && styleIndex <= 5)
    {
        //Make sure that the double is converted into the correct format (with '.' instead of ',')
        if (double.TryParse(cell.CellValue.Text, NumberStyles.Float, CultureInfo.InvariantCulture, out double dateTimeDouble))
        {
            return DateTime.FromOADate(dateTimeDouble);
        }
    }
}
--

In MS Excel, we read the Stylesheet and interpret it as date, because other DataTypes have no Stylesheet (StyleIndex=0). +
After that, we convert again the OADate into DateTime. +
With the Stylesheet, Excel is able to interpret the cell value as Date and you can see the Date in the Excel as Date. +

{nbsp} +

Link: Go to <<1.0.0.0 OpenXML/Excel - Technical Background>> +
Link: Go to <<0.0.0.0 Table of Contents>> +

{nbsp} +

=== 1.2.0.0 Glossary

{nbsp} +

==== 1.2.1.0 OpenXML Classes

{nbsp} +

|===
|       Class           |       Alternative Term            |     Definition

| OpenXML               |                                   | Open Source File Format to create spreadsheets, textdocuments, presentations and more.

| SpreadsheetDocument   | Excel File                        | This is a spreadsheet, a file that is mostly used for tables

| WorkBook              |                                   | A WorkBook contains and groups multiple worksheets.

| WorkSheet             | Excel Table                       | This is the document that does contain a table.

| SheetData             | Table (Meta) Data                 | This contains the (meta) data of the worksheets and is used to read and write worksheets.

| SharedStringTable     |                                   | Spreadsheets do use a 'SharedStringTable', where all strings are saved. In the cells are only the references to this table. This is used to reduce storage, because strings with the same content are stored only once.

| StyleSheet            | Theme Templet                     | With this it is possible to create various styles and formats for cells.
|===

{nbsp} +

==== 1.2.2.0  Used Terms and Definitions

{nbsp} +

===== 1.2.2.1 Empty Table Design

{nbsp} +

Before we define and explain some terms, we need to explain some basics how a table is designed. +

|===
|       |   A   |   B   |   C   |   D   |   E   |   F
|   1   |       |       |       |       |       |
|   2   |       |       |       |       |       |
|   3   |       |       |       |       |       |
|   4   |       |       |       |       |       |
|   5   |       |       |       |       |       |
|   6   |       |       |       |       |       |
|===

('LetterID') ('LetterIndex') +
At the top row, there a letters that fo from A to Z and from AZ zo ZZ and so on. +
We call the the letterIDs (sometimes letterIndex), because these letters are used to identify the columns. +

('RowIndex') + 
In the first column, there are numbers from 1 to infinity. +
This is the RowIndex that is used to identify the rows where the cells are. +

('CellReference') +
Every cell has an CellReference that consists of a letterID and a RowIndex. +
Examples of Cellrefernences are: +
"A1", "B2", "C3", "D4", "E5", "F6".

('RefereceCell') +
Cells can have a 'ReferenceCell', which is the cell above that cell. +
For example: +
A cell with CellReference 'C3' has the ReferenceCell 'C2' and the cell with Cellreference 'C2' has the ReferenceCell 'C1'. +
The cell with CellReference 'C1' has no (null) ReferenceCell. +
Also cells where the cell above have no values have no (null) ReferenceCell. +

{nbsp} +

===== 1.2.2.2 Used Table Design

{nbsp} +

Because we need to identify where we want to insert new entries in a specific place or want to read specific entries, we need to use identifier. +

|===
|       |   A   |   B   |   C   |   D   |   E   |   F
|   1   |Header1|Header2|Header3|Header4|Header5|Header6
|   2   |       |       |       |       |       |
|   3   |       |       |       |       |       |
|   4   |       |       |       |       |       |
|   5   |       |       |       |       |       |
|   6   |       |       |       |       |       |
|===

('header-columns') ('headers') (Column-names) +
We use 'headers' or 'header-columns' (sometimes called 'column-names') to identify the places where specific entries are entered. +
These 'headers' are basically regular cells containing a string we use to group and identify values in the column (like the 'column-name' in a database). +
When we want to read only specific entries of specific headers, we first seach for the header and get the 'letterID'. +

For example: +
"Header1" has 'letterID' A, +
"Header2" has 'letterID' B, +
"Header3" has 'letterID' C, [...]. +

Then, we can read all rows below and we can read only the cells that do have the 'letterIDs' from the wished headers. +

For example when we want to read from: +
"Header1" we get all below cells where the CellReference does contain the 'letterID' A, +
"Header2" we get all below cells where the CellReference does contain the 'letterID' B, +
"Header3" we get all below cells where the CellReference does contain the 'letterID' C, [...]. +

{nbsp} +

Link: Go to <<1.0.0.0 OpenXML/Excel - Technical Background>> +
Link: Go to <<0.0.0.0 Table of Contents>> +

{nbsp} +

== 2.0.0.0 Code Documentation

{nbsp} +

=== 2.1.0.0 Public APIs

{nbsp} +

==== 2.1.1.0 RowInsert Class

{nbsp} +

===== 2.1.1.1 Insert with List

{nbsp} +

[source]
--
/// <summary>
/// Inserts all values of (parameter) 'columnValues' into a new row.
/// </summary>
/// <param name="filepath">
/// Relative/absolute filepath to a *.xlsx file where the new row should be inserted.
/// </param>
/// <param name="worksheetName">
/// Name of the worksheet in the *.xlsx file where the new row should be inserted.
/// </param>
/// <param name="columnValues">
/// Every value of (parameter) 'columnValues' is the value of a new cell in the new row.
/// </param>

public static void Insert(string filepath, string worksheetName, List<object> columnValues)
--

The parameter 'columnValues' is a List of Objects. +
Every object represents a new cell entry. +
This function will insert all list-entries in the same order into the table as the order is in the entered list. +

Example: +
'columnValues' = new() { "Hello World", 0, 1.0, true, 22.05.2021 } +
will create into an empty table: +

|===
|       |   A       |   B       |   C       |   D       |   E       |   F
|   1   |Hello World| 0         | 1.0       | true      |22.02.2021 |
|   2   |           |           |           |           |           |
|   3   |           |           |           |           |           |
|   4   |           |           |           |           |           |
|   5   |           |           |           |           |           |
|   6   |           |           |           |           |           |
|===

The data-types in the table are same as the data-type of the entered values. +

{nbsp} +

===== 2.1.1.1 Insert with Dictionary

{nbsp} +

[source]
--
/// <summary>
/// Inserts all values of (parameter) 'columnNamesAndValues' into a new row.
/// </summary>
/// <param name="filepath">
/// Relative/absolute filepath to a *.xlsx file where the new row should be inserted.
/// </param>
/// <param name="worksheetName">
/// Name of the worksheet in the *.xlsx file where the new row should be inserted.
/// </param>
/// <param name="columnNamesAndValues">
/// Every KeyValuePair represents one cell with value, where the key is the (so called) 'header-column' where the cell should be inserted below this (so called) 'header-column'
/// and the value is the value of the cell.
/// </param>

public static void Insert(string filepath, string worksheetName, Dictionary<string, object> columnNamesAndValues)
--

The parameter 'columnNamesAndValues' is a dictionary where every KeyValuePair represents one entry. +
The Key is the 'column-name' or the 'header' we alrteady explained in chapter '1.2.2.2 Used Table Design'. +
That means this function requires that the table does contains these 'header-columns'. +
The values of the KeyValuePair are the entries that should be inserted into an empty row and into a cell with the same 'letterID' as the 'header-column' from the key has. +

Example: +
We have the table: +

|===
|       |   A   |   B   |   C   |   D   |   E   |   F
|   1   |Header1|Header2|Header3|Header4|Header5|Header6
|   2   |       |       |       |       |       |
|   3   |       |       |       |       |       |
|   4   |       |       |       |       |       |
|   5   |       |       |       |       |       |
|   6   |       |       |       |       |       |
|===

In the first row are all of our 'header-columns'. +
When we do want to insert values using the Dictionary, it would look like this: +
'columnNamsAndValues' = new() { { "Header1", "Hello World" }, { "Header3", 1.0 }, { "Header5", 22.05.2021 }, { "Header2", 0 }, { "Header4", true } } +

Even if the order of the 'headers' are different, the values will be inserted below the correct header in the key and the table would look like this: +

|===
|       |   A       |   B       |   C       |   D       |   E       |   F
|   1   | Header1   | Header2   | Header3   | Header4   | Header5   |Header6
|   2   |Hello World| 0         | 1.0       | true      |22.02.2021 |
|   3   |           |           |           |           |           |
|   4   |           |           |           |           |           |
|   5   |           |           |           |           |           |
|   6   |           |           |           |           |           |
|===

This is what we call an intelligent insertion, because before the values will be inserted into a new row we search for the 'header-column' that is used in the key and get the 'letterID', so that the cell has the same 'letterID' in the 'CellReference' as the 'column' in the key. +
Again, the cell value and data-type do match the entered value in the value of the KeyValuePair. +

{nbsp} +

==== 2.1.2.0 RowSelect Class

{nbsp} +

===== 2.1.2.1 SelectAsRows with List

{nbsp} +

[source]
--
/// <summary>
/// Reads and returns all values below of entered (so-called) 'header-columns' in (parameter) 'columnNames'.
/// </summary>
/// <param name="filepath">
/// Relative/absolute filepath to a *.xlsx file that should be opened.
/// </param>
/// <param name="worksheetName">
/// Name of the worksheet in the *.xlsx file that should be read.
/// </param>
/// <param name="columnNames">
/// Names of all columns that should be used to identify the header, so that it'll only read values that are below those headers.
/// </param>
/// <returns>
/// Returns a List of Dictionary. 
/// Every List entry (Every dictionary) represents one row.
/// Every KeyValuePair of the Dictionarys has a key that is the (so called) 'header-column' and the value is a value in the row, that is below this (so called) 'header-column'.
/// </returns>

public static List<Dictionary<string, object>> SelectAsRows(string filepath, string worksheetName, List<string> columnNames)
--

The parameter 'columnNames' are the 'header-columns' where the values below should be selected. +
The returning List contains multiple Dictionaries, where every Dictionary represents one row. +
There are the same number KeyValuePairs in the Dictionary as entries in 'columnNames'. +
Every KeyValuePair in the dictionaries contains in the key a (so called) 'header-columns' and in the value the value in the row that is below this (so called) 'header-column'. +

Example: +
We have the table: +

|===
|       |   A       |   B       |   C       |   D       |   E       |   F
|   1   | Header1   | Header2   | Header3   | Header4   | Header5   |Header6
|   2   |Hello World| 0         | 1.0       | true      |22.02.2021 |
|   3   |Foo Bar    | 10        | 2.2       | false     |23.02.2021 |
|   4   |Spreadsheet| 42        | 3.14      | true      |24.02.2021 |
|   5   |           |           |           |           |           |
|   6   |           |           |           |           |           |
|===

We use the entries in the first row as 'header-column'. +
When we select entries, it would look like this: +
'columnNames' = new() { "Header1", "Header5", "Header3" } +

We get a List of Dictionarys that would look like this: +
List<Dictionary> = new() +
{ +
new() { { "Header1", "Hello World" }, { "Header5", 22.02.2021 }, { "Header3", 1.0 } }, +
new() { { "Header1", "Foo Bar" }, { "Header5", 23.02.2021 }, { "Header3", 2.2 } }, +
new() { { "Header1", "Spreadsheet" }, { "Header5", 24.02.2021 }, { "Header3", 3.14 } } +
} +

We can create entries with the rows like this: +

[source]
--
public static List<T> GetAllFromTable<T>(string filepath, string worksheetName, List<string> headerColumns, Func<Dictionary<string, object>, T> convertAttributesFunction)
{
    List<T> dataSets = new();

    List<Dictionary<string, object>> table = RowSelect.SelectAsRows(filepath, worksheetName, headerColumns);
    if (table.Any())
    {
        foreach (Dictionary<string, object> row in table)
        {
            dataSets.Add(convertAttributesFunction(row));
        }
    }

    return dataSets;
}
--

We can call a function that uses the keys of the dictionary to add the value into the right position of this entry. +

{nbsp} +

===== 2.1.2.2 SelectWhereAsRows with List and Where Condition

{nbsp} +

P +
L +
A +
C +
E +
H +
O +
L +
D +
E +
R +

{nbsp} +

===== 2.1.2.3 SelectAsColumns with List

{nbsp} +

[source]
--
/// <summary>
/// Reads and returns all values below of entered (so-called) 'header-columns' in (parameter) 'columnNames'.
/// </summary>
/// <param name="filepath">
/// Relative/absolute filepath to a *.xlsx file that should be opened.
/// </param>
/// <param name="worksheetName">
/// Name of the worksheet in the *.xlsx file that should be read.
/// </param>
/// <param name="columnNames">
/// Names of all columns that should be used to identify the header, so that it'll only read values that are below those headers.
/// </param>
/// <returns>
/// Returns a Dictionary, where the keys are the entered (parameter) 'columnNames' and the values of those keys are all read values that are below of those (so called) 'header-column'.
/// </returns>

public static Dictionary<string, List<object>> SelectAsColumns(string filepath, string worksheetName, List<string> columnNames)
--

The parameter 'columnNames' are the 'header-columns' where the values below should be selected. +
The returning Dictionary contains multiple KeyValuePairs. +
There are the same number KeyValuePairs in the Dictionary as entries in 'columnNames'. +
Every entry of 'columnNames' becomes a Key of a KeyValuePair. +
The Value are all values that are below the 'header-column' with the same name as the entry in 'columnNames'. +

Example: +
We have the table: +

|===
|       |   A       |   B       |   C       |   D       |   E       |   F
|   1   | Header1   | Header2   | Header3   | Header4   | Header5   |Header6
|   2   |Hello World| 0         | 1.0       | true      |22.02.2021 |
|   3   |Foo Bar    | 10        | 2.2       | false     |23.02.2021 |
|   4   |Spreadsheet| 42        | 3.14      | true      |24.02.2021 |
|   5   |           |           |           |           |           |
|   6   |           |           |           |           |           |
|===

We use the entries in the first row as 'header-column'. +
When we select entries, it would look like this: +
'columnNames' = new() { "Header1", "Header5", "Header3" } +

We get a dictionary  that would look like this: +
Dictionary = new() +
{ +
{ "Header1", new() { "Hello World", "Foo Bar", "Spreadsheet" } } +
{ "Header5", new() { 22.02.2021, 23.02.2021, 24.02.2021 } } +
{ "Header3", new() { 1.0, 2.2, 3.14 } } +
} +

As we see, we don't return a row where the entries have the same order as the input, we return the columns. +
That makes us more flexible, because we can select specific columns and search only in there or we can combine the columns to new entries. +

When we want to recreate rows, we must remeber that all entries in the lists at the same index do belong to the same row. +

Example: +

Row row = new() { Dictonary["Header1"][0], Dictonary["Header3"][0], Dictonary["Header5"][0] } +

Then we would have the row: +
{ "Hello World", 1.0, 22.02.2021 } +

Same in: +

Row row = new() { Dictonary["Header1"][2], Dictonary["Header3"][2], Dictonary["Header5"][2] } +

Then we would have the row: +
{ "Spreadsheet", 3.14, 24.02.2021 } +

As we see, all those entries where in the same row in the table. +
So all Lists in the values in the KeyValuePairs can be used this way. +
When we access them with the same index value we get one row. +
Note that all lists have the same lenght. +

That makes it possible to recreate the rows this way: +

[source]
--
public static List<T> GetAllFromTable<T>(string filepath, string worksheetName, List<string> headerColumns, Func<Dictionary<string, object>, T> convertAttributesFunction)
{
    List<T> dataSets = new();

    Dictionary<string, List<object>> table = RowSelect.Select(filepath, worksheetName, headerColumns);
    if (table.Any())
    {
        int rowsCount = table[headerColumns[0]].Count;

        for (int rowIndex = 0; rowIndex < rowsCount; rowIndex++)
        {
            Dictionary<string, object> row = new();
            for (int i = 0; i < headerColumns.Count; i++)
            {
                row.Add(headerColumns[i], table[headerColumns[i]][rowIndex]);
            }
            dataSets.Add(convertAttributesFunction(row));
        }
    }

    return dataSets;
}
--

First, we get the lenght of the first list (remember all lists have the same lenght). +
Then, we iterate throu all KeyValuePairs. +
We access the Dictionary List entries with the key and the current row index: +
table[header/column][rowIndex] +
When we add those results into a row/list, we can recreate the rows in the table. +

{nbsp} +

===== 2.1.2.4 SelectWhereAsColumns with List and Where Condition

{nbsp} +

P +
L +
A +
C +
E +
H +
O +
L +
D +
E +
R +

{nbsp} +


==== 2.1.3.0 RowUpdate Class

{nbsp} +

===== 2.1.3.1 Update with Where Condition

{nbsp} +

[source]
--
/// <summary>
/// Updates all rows with the entered values in (parameter) 'updateColumnsAndNewValues' that do match all the conditions in (parameter) 'whereColumnNamesAndConditions).
/// </summary>
/// <param name="filepath">
/// Relative/absolute filepath to a *.xlsx file where the rows should be updated.
/// </param>
/// <param name="worksheetName">
/// Name of the worksheet in the *.xlsx file where the rows should be updated.
/// </param>
/// <param name="whereColumnNamesAndConditions">
/// Every KeyValuePair represents one condition, where the key is the (so called) 'header-column' 
/// and the value is the condition a cell should match (the cell should match data-type and value) and that is below the (so called) 'header-column' in the key.
/// </param>
/// <param name="updateColumnsAndNewValues">
/// Every KeyValuePair represents one cell with value, where the key is the (so called) 'header-column' where the cells that should be updated are below those (so called) 'header-columns'
/// and the value is the new value of the cell.
/// </param>
/// <returns>
/// Number of updated rows.
/// </returns>

public static int Update(string filepath, string worksheetName, Dictionary<string, object> whereColumnNamesAndConditions, Dictionary<string, object> updateColumnsAndNewValues)
--

The parameter 'whereColumnNamesAndCoditions' contains multiple KeyValuePairs, where the Keys are the 'header-columns' and the Value is the condition a cell below this 'header-colummns' (a cell with the same 'letterID' as the 'header-column') must match (data-type and value). +
The conditions are combined with AND (that means a row in the table must match ALL conditions in 'whereColumnNamesAndConditions'). +

The parameter 'updateColumnsAndNewValues' contains multiple KeyValuePairs, where the Keys are the 'header-column' and the Value is the new value for the cell. +
The cell that will be updated must be below the 'header-column' in the key (the cell must have the same 'letterID' as the 'header-column'). +

This function will update ALL rows in the table that do match (all) the conditions in 'whereColumnNamesAndConditions' with the values in 'updateColumnsAndNewValues' and will return the number of updated rows. +

Example: +
We have the table: +

|===
|       |   A       |   B       |   C       |   D       |   E       |   F
|   1   | Header1   | Header2   | Header3   | Header4   | Header5   |Header6
|   2   |Hello World| 0         | 1.0       | true      |22.02.2021 |
|   3   |Foo Bar    | 10        | 2.2       | false     |23.02.2021 |
|   4   |Spreadsheet| 42        | 3.14      | true      |24.02.2021 |
|   5   |Worksheet  | 20        | 0.11      | false     |24.05.2021 |
|   6   |OOP        | 2         | 9.81      | true      |24.05.2021 |
|===

When we use: +
'whereColumnNamesAndConditions' = new() { { "Header4", true }, { "Header5", 24.05.2021 } } +
'updateColumnsAndNewValues' = new() { { "Header2", 0 }, { "Header3", 0.0 }, { "Header5", 25.05.2021} } +

When we run the function, the table will look like this after that: +


|===
|       |   A       |   B       |   C       |   D       |   E       |   F
|   1   | Header1   | Header2   | Header3   | Header4   | Header5   |Header6
|   2   |Hello World| 0         | 1.0       | true      |22.02.2021 |
|   3   |Foo Bar    | 10        | 2.2       | false     |23.02.2021 |
|   4   |Spreadsheet| 0         | 0.0       | true      |25.02.2021 |
|   5   |Worksheet  | 20        | 0.11      | false     |24.05.2021 |
|   6   |OOP        | 0         | 0.0       | true      |25.05.2021 |
|===

And the function returns the number 2 (because 2 rows where updated). +
As we see, all rows that match all conditions where updated with all new values. +
All other rows stay unaffected. +

{nbsp} +

==== 2.1.4.0 RowDelete Class

{nbsp} +

===== 2.1.4.1 Delete with Where Condition

{nbsp} +

[source]
--
/// <summary>
/// Deletes all rows that do match all the conditions in (parameter) 'whereColumnNamesAndValues'.
/// </summary>
/// <param name="filepath">
/// Relative/absolute filepath to a *.xlsx file where the rows should be deleted.
/// </param>
/// <param name="worksheetName">
/// Name of the worksheet in the *.xlsx file where the rows should be deleted.
/// </param>
/// <param name="whereColumnNamesAndConditions">
/// Every KeyValuePair represents one condition, where the key is the (so called) 'header-column' 
/// and the value is the condition a cell should match (the cell should match data-type and value) and that is below the (so called) 'header-column' in the key.
/// </param>
/// <returns>
/// Number of deleted rows.
/// </returns>

public static int Delete(string filepath, string worksheetName, Dictionary<string, object> whereColumnNamesAndConditions)
--

The parameter 'whereColumnNamesAndCoditions' contains multiple KeyValuePairs, where the Keys are the 'header-columns' and the Value is the condition a cell below this 'header-colummns' (a cell with the same 'letterID' as the 'header-column') must match (data-type and value). +
The conditions are combined with AND (that means a row in the table must match ALL conditions in 'whereColumnNamesAndConditions'). +

This function will delete ALL rows in the table that do match (all) the conditions in 'whereColumnNamesAndConditions' and returns the number of deleted rows. +

Example: +
We have the table: +

|===
|       |   A       |   B       |   C       |   D       |   E       |   F
|   1   | Header1   | Header2   | Header3   | Header4   | Header5   |Header6
|   2   |Hello World| 0         | 1.0       | true      |22.02.2021 |
|   3   |Foo Bar    | 10        | 2.2       | false     |23.02.2021 |
|   4   |Spreadsheet| 42        | 3.14      | true      |24.02.2021 |
|   5   |Worksheet  | 20        | 0.11      | false     |24.05.2021 |
|   6   |OOP        | 2         | 9.81      | true      |24.05.2021 |
|===

When we use: +
'whereColumnNamesAndConditions' = new() { { "Header4", true }, { "Header5", 24.05.2021 } } +

When we run the function, the table will look like this after that: +


|===
|       |   A       |   B       |   C       |   D       |   E       |   F
|   1   | Header1   | Header2   | Header3   | Header4   | Header5   |Header6
|   2   |Hello World| 0         | 1.0       | true      |22.02.2021 |
|   3   |Foo Bar    | 10        | 2.2       | false     |23.02.2021 |
|   4   |           |           |           |           |           |
|   5   |Worksheet  | 20        | 0.11      | false     |24.05.2021 |
|   6   |           |           |           |           |           |
|===

And the function returns the number 2 (because 2 rows where deleted). +
As we see, all rows that match all conditions where deleted. +
All other rows stay unaffected. +

In this simple version, the rows will stay empty and the references won't change. +
This won't effect how data will be read or written, but when you open the spreadsheet manually, you can see those empty rows. +

{nbsp} +

===== 2.1.4.2 Delete Advanced with Where Condition

{nbsp} +

[source]
--
/// <summary>
/// Deletes all rows that do match all the conditions in (parameter) 'whereColumnNamesAndValues'.
/// </summary>
/// <param name="filepath">
/// Relative/absolute filepath to a *.xlsx file where the rows should be deleted.
/// </param>
/// <param name="worksheetName">
/// Name of the worksheet in the *.xlsx file where the rows should be deleted.
/// </param>
/// <param name="whereColumnNamesAndConditions">
/// Every KeyValuePair represents one condition, where the key is the (so called) 'header-column' 
/// and the value is the condition a cell should match (the cell should match data-type and value) and that is below the (so called) 'header-column' in the key.
/// </param>
/// <returns>
/// Number of deleted rows.
/// </returns>

public static int DeleteAdvanced(string filepath, string worksheetName, Dictionary<string, object> whereColumnNamesAndConditions)
--

The parameter 'whereColumnNamesAndCoditions' contains multiple KeyValuePairs, where the Keys are the 'header-columns' and the Value is the condition a cell below this 'header-colummns' (a cell with the same 'letterID' as the 'header-column') must match (data-type and value). +
The conditions are combined with AND (that means a row in the table must match ALL conditions in 'whereColumnNamesAndConditions'). +

This function will delete ALL rows in the table that do match (all) the conditions in 'whereColumnNamesAndConditions' and returns the number of deleted rows. +

Example: +
We have the table: +

|===
|       |   A       |   B       |   C       |   D       |   E       |   F
|   1   | Header1   | Header2   | Header3   | Header4   | Header5   |Header6
|   2   |Hello World| 0         | 1.0       | true      |22.02.2021 |
|   3   |Foo Bar    | 10        | 2.2       | false     |23.02.2021 |
|   4   |Spreadsheet| 42        | 3.14      | true      |24.02.2021 |
|   5   |Worksheet  | 20        | 0.11      | false     |24.05.2021 |
|   6   |OOP        | 2         | 9.81      | true      |24.05.2021 |
|===

When we use: +
'whereColumnNamesAndConditions' = new() { { "Header4", true }, { "Header5", 24.05.2021 } } +

When we run the function, the table will look like this after that: +


|===
|       |   A       |   B       |   C       |   D       |   E       |   F
|   1   | Header1   | Header2   | Header3   | Header4   | Header5   |Header6
|   2   |Hello World| 0         | 1.0       | true      |22.02.2021 |
|   3   |Foo Bar    | 10        | 2.2       | false     |23.02.2021 |
|   4   |Worksheet  | 20        | 0.11      | false     |24.05.2021 |
|   5   |           |           |           |           |           |
|   6   |           |           |           |           |           |
|===

And the function returns the number 2 (because 2 rows where deleted). +
As we see, all rows that match all conditions where deleted. +
All other rows stay unaffected. +

In this advanced function, the rows that are not deleted follow up and fill the places of the deleted rows and the references will be updated. +
This means there will be no empty rows when you open the spreadsheet manually. +

Because all references will be updated, this advanced version takes more resources and time than the simple version. +

{nbsp} +

==== 2.1.5.0 Others

{nbsp} +

===== 2.1.5.1 WorksheetExists

{nbsp} +

[source]
--
/// <summary>
/// Check if a worksheet does exist in a spreadsheet.
/// </summary>
/// <param name="filepath">
/// Relative/absolute filepath to a *.xlsx file that should be opened.
/// </param>
/// <param name="worksheetName">
/// Name of the worksheet that should be searched.
/// </param>
/// <returns>
/// True, if worksheet with (parameter) 'worksheetName' does exist, otherwise False.
/// </returns>

public static bool WorksheetExists(ref string filepath, string worksheetName)
{
    if (!CheckPathExist(ref filepath))
        return false;

    SpreadsheetDocument spreadsheetDocument = SpreadsheetDocument.Open(filepath, false);

    //Search for specific sheet
    IEnumerable<Sheet> sheetsIEnum = spreadsheetDocument?.WorkbookPart?.Workbook?.Descendants<Sheet>()?.Where(s => s.Name == worksheetName);
    //If specified sheet does not exists => return false
    bool isExists = sheetsIEnum.Any();

    spreadsheetDocument.Close();

    return isExists;
}
--

This function checks if a specified worksheet does exist in a specified spreadsheet. +

{nbsp} +

===== 2.1.5.2 CheckPathExists

{nbsp} +

[source]
--
/// <summary>
/// Check if a path at the specified (parameter) 'filepath' does exist. 
/// If the filepath is too long it'll try to access directly to the OS-File-System.
/// </summary>
/// <param name="filepath">
/// The path to the file that should be searched.
/// If the filepath is too long it'll try to access directly to the OS-File-System to search for the file.
/// </param>
/// <returns>
/// True, if the file exists, otherwise false.
/// </returns>

public static bool CheckPathExist(ref string filepath)
{
    CheckAndConvertLongFilePath(ref filepath);

    //If the path exists, it returns true and other functions can work further
    return File.Exists(filepath);
}
--

This function checks if a specified file does exist on the filepath. +

If the path is longer than 256 characters, it'll add the prefix '\\?\' so that the APIs can directly access the WINDOWS File-System. +
That is why we use 'ref filepath', so that the filepath is extended with the prefix '\\?\'. +
The prefix '\\?\' is ONLY supported on WINDOWS, where the 'MAX_PATH is regularly 260' characters (longer paths would throw a PathTooLOngException). +
To prevent that, the prefix '\\?\' is used to directly access the WINDOWS File-System, where the path supports longer paths. +
The prefix '\\?\' is not supported by all APIs (some APIs cannot use this prefix to access the OS-File-System). +

{nbsp} +

===== 2.1.5.3 IsIDOfWorksheet

{nbsp} +

[source]
--
/// <summary>
/// Checks if a specified ID does exist in a worksheet of the spreadsheet and that is below a specific (so called) 'header-column'.
/// </summary>
/// <param name="filepath">
/// Relative/absolute filepath to a *.xlsx file that should be opened.
/// </param>
/// <param name="worksheetName">
/// Name of the worksheet that should be opened.
/// </param>
/// <param name="headerColumnAndID">
/// The key is the (so called) 'header-column' 
/// and the value is the condition a cell should match (the cell should match data-type and value) and that is below the (so called) 'header-column' in the key.
/// </param>
/// <returns>
/// True, if the value in (parameter) 'headerColumnAndID' was found below the (so called) 'header-column' below the key of (parameter) 'headerColumnAndID'.
/// </returns>

public static bool IsIDOfWorksheet(string filepath, string worksheetName, KeyValuePair<string, object> headerColumnAndID)
--

This function checks if a specified ID does exist in a specified worksheet. +

The key of 'headerColumnAndID' is the (so called) 'header-column' and the value is a condition a cell must match (it must match data-type and value) and must be below this (so called) 'header-column'. +

===== 2.1.5.4 CheckHeaderColumnsExist

{nbsp} +

[source]
--
/// <summary>
/// Check if a row with all of the entered (so called) 'header-columns' do exist in the worksheet.
/// </summary>
/// <param name="filepath">
/// Relative/absolute filepath to a *.xlsx file that should be opened.
/// </param>
/// <param name="worksheetName">
/// Name of the worksheet that should be opened.
/// </param>
/// <param name="headerColumns">
/// Every entry represents one (so called) 'header-column' that should be searched.
/// </param>
/// <returns>
/// True, if all (so called) 'header-columns' where found in the same row, otherwise false.
/// </returns>

public static bool CheckHeaderColumnsExist(string filepath, string worksheetName, List<object> headerColumns)
--

This function checks if all specified 'header-columns' of (parameter) 'headerColumns' where found in the same row. +

All 'header-columns' must be in the same row. +
If one 'header-column' is missing in the row, it'll search until the end of the document and then return false if no row was found that contains all specified 'header-columns' in (parameter) 'headerColumns'. +

{nbsp} +

Link: Go to <<2.0.0.0 Code Documentation>> +
Link: Go to <<0.0.0.0 Table of Contents>> +

{nbsp} +

=== 2.2.0.0 Technical Documentation and Private APIs (Selection)

{nbsp} +

==== 2.2.1.0 SharedString

Spreadsheet do use a SharedStringTable to store strings. +
In the cells will be only references to a specific entry in the SharedStringTable stored. +
A string can be referenced by multible cells, if they share the same string content. +
(That's why it called SharedStringTable => A Table for Shared-Strings) +


===== 2.2.1.1 (API) GetSharedStringTablePart
[source]
---
private static SharedStringTablePart GetSharedStringTablePart(ref SpreadsheetDocument spreadsheetDocument)
{
    SharedStringTablePart sharedStringTablePart;
    if (spreadsheetDocument.WorkbookPart.GetPartsOfType<SharedStringTablePart>().Any())
    {
        sharedStringTablePart = spreadsheetDocument.WorkbookPart.GetPartsOfType<SharedStringTablePart>().First();
    }
    else
    {
        sharedStringTablePart = spreadsheetDocument.WorkbookPart.AddNewPart<SharedStringTablePart>();
    }

    return sharedStringTablePart;
}
---

First, we need to check if the spreadsheet has an SharedStringTable. +
A SharedStringTable must be created explicitly. +
If it has none, we easily can create a SharedStringTable in the spreadsheet. +

Because the cells only store the references, we need to parse throu the SharedStringTable to check if the String already exists (to safe storage). +

We can do this this way: +

===== 2.2.1.2 (API) InsertSharedStringItem
[source]
---
// Given text and a SharedStringTablePart, creates a SharedStringItem with the specified text 
// and inserts it into the SharedStringTablePart. If the item already exists, returns its index.
protected static int InsertSharedStringItem(string text, ref SharedStringTablePart sharedStringTablePart)
{
    // If the part does not contain a SharedStringTable, create one.
    if (sharedStringTablePart.SharedStringTable is null)
    {
        sharedStringTablePart.SharedStringTable = new SharedStringTable();
    }

    int i = 0;
    // Iterate through all the items in the SharedStringTable. If the text already exists, return its index.
    foreach (SharedStringItem item in sharedStringTablePart.SharedStringTable.Elements<SharedStringItem>())
    {
        if (item.InnerText == text)
        {
            return i;
        }

        i++;
    }

    // The text does not exist in the part. Create the SharedStringItem and return its index.
    sharedStringTablePart.SharedStringTable.AppendChild(new SharedStringItem(new DocumentFormat.OpenXml.Spreadsheet.Text(text)));
    sharedStringTablePart.SharedStringTable.Save();

    return i;
}
---

Then we can add the (cell) entry like this: +

===== 2.2.1.3 (API) AddSharedString
[source]
---
protected static void AddSharedString(ref SpreadsheetDocument spreadsheetDocument, ref Cell newCell, string text)
{
    //If no SharedStringTable is created, we create new one if no exist.
    //We shouldn't create a SharedStringTable if it's not used, because it can corrupt the file
    SharedStringTablePart sharedStringTablePart = GetSharedStringTablePart(ref spreadsheetDocument);

    int index = InsertSharedStringItem(text, ref sharedStringTablePart);

    newCell.DataType = new EnumValue<CellValues>(CellValues.SharedString);
    newCell.CellValue = new CellValue(index.ToString());
}
---

{nbsp} +

==== 2.2.2.0 Cells

We can create cells this way: +

===== 2.2.2.1 (API) CreateCell
[source]
---
//cellReferenceIDAndValue: <cellReference, value>
protected static void CreateCell(ref SpreadsheetDocument spreadsheetDocument, ref Row row, KeyValuePair<string, object> cellReferenceIDAndValue)
{
    //Get reference cell
    //The referenceCell is the Cell in the previous row with the same letterIndex
    Cell referenceCell = GetReferenceCell(row, cellReferenceIDAndValue.Key);
    Cell newCell = new() { CellReference = cellReferenceIDAndValue.Key };
    row.InsertBefore(newCell, referenceCell);

    UpdateCell(ref spreadsheetDocument, ref newCell, cellReferenceIDAndValue.Value);
}
---

First, we get the referenceCell. +
The referenceCell is a cell in the same column (with the same 'letterID') in the previous (upper) row. +
If the referenceCell does not exists or is empty, the referenceCell is null. +

The CellReference is the 'column-letter' ('letterID') and the RowIndex. +

The cell can be saved this way: +

===== 2.2.2.1 (API) UpdateCell
[source]
---
protected static void UpdateCell(ref SpreadsheetDocument spreadsheetDocument, ref Cell cell, object newValue)
{
    switch (newValue)
    {
        case string objstr:
            AddSharedString(ref spreadsheetDocument, ref cell, objstr);
            break;

        case DateTime objdate:
            //Normal way. Does NOT work for xlsx (!)
            //string strdate = objdate.ToOADate().ToString();
            //cell.DataType = CellValues.Date;
            //cell.CellValue = new CellValue(strdate);

            //"StyleIndex" is "1", because we added a new stylesheet (index 0 would be default) with "NumberFormatId=14"
            //is in the 2nd item of 'CellFormats' array.
            cell.DataType = new EnumValue<CellValues>(CellValues.Number);
            cell.StyleIndex = 1;
            cell.CellValue = new CellValue(objdate.ToOADate().ToString(CultureInfo.InvariantCulture));
            break;

        case bool objbool:
            AddSharedString(ref spreadsheetDocument, ref cell, objbool.ToString());
            break;

        default:
            if (newValue is not null && Decimal.TryParse(newValue.ToString(), out decimal objdec))
            {
                cell.DataType = new EnumValue<CellValues>(CellValues.Number);
                cell.CellValue = new CellValue(objdec.ToString(CultureInfo.InvariantCulture));
            }
            else
            {
                //Enter an empty cell to make IO easier
                AddSharedString(ref spreadsheetDocument, ref cell, " ");
            }
            break;
    }
}
---

Normaly, OpenXML has a native support for boolean. +
This format is not suppported by MS Excel (MS Excel cannot work with the boolean format of OpenXML and must be implemented in other ways). +

Microsoft Excel can support the following data-types: +
String; DateTime; (Boolean); Numbers (Decimal); +
If you want to use other data-types than the specified, they should be converted into one of these data-types before inserting them into Public APIs (!) +

{nbsp} +

Link: Go to <<2.0.0.0 Code Documentation>> +
Link: Go to <<0.0.0.0 Table of Contents>> +

{nbsp} +